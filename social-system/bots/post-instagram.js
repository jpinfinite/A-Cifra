const { chromium } = require('playwright')
const delay = require('./utils/delay') // Adjusted path
const typeLikeHuman = require('./utils/typeLikeHuman') // Adjusted path
const fs = require('fs')
const path = require('path')

// Read from current.json generated by scheduler
const CURRENT_POST_PATH = path.join(__dirname, '../posts/current.json')

;(async () => {
  try {
    if (!fs.existsSync(CURRENT_POST_PATH)) {
        console.error("‚ùå Arquivo de post n√£o encontrado.")
        process.exit(1)
    }
    const post = JSON.parse(fs.readFileSync(CURRENT_POST_PATH, 'utf-8'))

    // Validar se imagem existe
    if (!fs.existsSync(post.image)) {
        console.error(`‚ùå Imagem n√£o encontrada: ${post.image}`)
        process.exit(1)
    }

    // Check storage path (relative to bot execution or absolute)
    // We assume storage is in social-system/storage now? Or reused from social-bot?
    // User structure says "bots" folder. session storage should probably be in ../storage
    const STORAGE_PATH = path.join(__dirname, '../storage/instagram.json')

    if (!fs.existsSync(STORAGE_PATH)) {
         // Fallback to try loading from old social-bot location if migration didn't happen
         const OLD_STORAGE = path.join(__dirname, '../../social-bot/storage/instagram.json')
         if (fs.existsSync(OLD_STORAGE)) {
             console.log("‚ö†Ô∏è Usando sess√£o do social-bot antigo...")
             fs.copyFileSync(OLD_STORAGE, STORAGE_PATH)
         } else {
             console.error("‚ùå Sess√£o n√£o encontrada. Fa√ßa login primeiro.")
             process.exit(1)
         }
    }

    const { chromium, devices } = require('playwright')
    // ... imports ...

    // Emulate Mobile Device (iPhone 12)
    const iPhone = devices['iPhone 12']

    const browser = await chromium.launch({ headless: false })
    const context = await browser.newContext({
      ...iPhone,
      storageState: STORAGE_PATH,
      permissions: ['geolocation'], // We grant it but then we don't supply coordinates, or better:
      // Actually, explicitly setting permissions to [] or specific ones might block the prompt.
      // Best way to BLOCK is to not grant, but sometimes prompts appear.
      // Let's use specific geolocation context option.
      geolocation: { latitude: -23.5505, longitude: -46.6333 }, // Sao Paulo (fake) to satisfy if needed
      permissions: [] // Reset permissions
    })
    // Better approach for blocking prompts:
    await context.grantPermissions([]) // Grant nothing
    // Or specifically for the domain:
    // await context.clearPermissions()

    // Actually, simply ignoring the prompt is hard.
    // The most robust way in Playwright to BLOCK location prompts is:
    await context.grantPermissions(['geolocation'], { origin: 'https://www.instagram.com' });
    // This GRANTS it so the prompt doesn't show up. It's safer than blocking which might show "blocked" UI.
    // Let's grant notifications too if possible? No, notifications usually ask.
    // Let's try granting geolocation to silence the prompt.


    const page = await context.newPage()
    await page.goto('https://www.instagram.com/')
    await delay(5000, 8000)

    // --- AGGRESSIVE POPUP HANDLER ---
    console.log("üõ°Ô∏è Iniciando varredura de popups...");
    for (let i = 0; i < 3; i++) { // Try 3 times
        try {
            const dismissSelectors = [
                'button:has-text("Agora n√£o")',
                'button:has-text("Not Now")',
                'button:has-text("Cancelar")',
                'button:has-text("Cancel")',
                'button:has-text("OK")',
                'div[role="button"]:has-text("OK")',
                'div[role="button"]:has-text("Agora n√£o")',
                '[aria-label="Close"]',
                '[aria-label="Fechar"]'
            ];

            for (const selector of dismissSelectors) {
                // Use a short timeout so we don't get stuck looking for one
                try {
                    const btn = await page.$(selector);
                    if (btn && await btn.isVisible()) {
                        console.log(`üßπ Fechando popup com seletor: ${selector}`);
                        await btn.click({ force: true });
                        await delay(1000, 1500);
                    }
                } catch(err) {}
            }

            // Blind click on common "OK" button location (Bottom-Center in Mobile)
            // iPhone 12 width is 390. Center ~195.
            // Popup usually bottom half. Let's try a safe spot if we suspect a modal.
            // But let's verify if we are blocked first? No, blind fire is safer for "do your best".
            if (i === 1) {
                 // Only on second attempt, blindly click center of screen to dismiss "Tap to close"
                 // or exact coordinates for that blue button.
                 // Blue button in screenshot is roughly 50% down or slightly lower?
                 // Looking at screenshot: It's centered.
                 // Let's try clicking the "OK" text if it exists regardless of button tag
                 const okText = await page.getByText('OK', { exact: true });
                 if (await okText.isVisible()) {
                     console.log("üßπ Clicando em texto 'OK' solto...");
                     await okText.click();
                 }
            }

        } catch (e) {
            console.log("Erro no handler de popup (ignorado):", e.message);
        }
        await delay(1000);
    }
    console.log("üõ°Ô∏è Varredura finalizada.");
    // ---------------------

    // --- CREATE BUTTON HANDLER ---
    const createSelectors = [
        'svg[aria-label="Nova publica√ß√£o"]',
        'svg[aria-label="New post"]',
        'svg[aria-label="Criar"]',
        'svg[aria-label="Create"]',
        'span:has-text("Criar")',
        'span:has-text("Create")',
        'div[role="button"]:has-text("Criar")',
        'a[role="link"]:has-text("Criar")'
    ];

    let createClicked = false;
    for (const selector of createSelectors) {
        try {
            if (await page.isVisible(selector)) {
                console.log(`Bot√£o Criar detectado: ${selector}`);
                await page.click(selector);
                createClicked = true;
                break;
            }
        } catch (e) {}
    }

    if (!createClicked) {
        // Last resort: Try clicking by position or specific class if known, or throw
        console.error("‚ùå N√£o foi poss√≠vel encontrar o bot√£o Criar pelos seletores conhecidos.");
        // Attempt generic fallback for "+" icon often used
        try {
           await page.click('svg[width="24"][height="24"]'); // Risky but common
        } catch(e) {
           throw new Error("Bot√£o Criar inalcan√ß√°vel");
        }
    }

    await delay()

    // Upload imagem
    // Input is often hidden, so we wait for handle or attached state, not visibility
    const fileInput = await page.waitForSelector('input[type="file"]', { state: 'attached' })
    await fileInput.setInputFiles(post.image)
    await delay(5000, 7000)

    await page.click('text=Avan√ßar')
    await delay(2000, 4000)

    await page.click('text=Avan√ßar')
    await delay()

    // Legenda
    await typeLikeHuman(
      page,
      'div[role="textbox"]',
      `${post.caption}\n\n${post.hashtags}`
    )

    await delay(3000, 5000)

    await page.click('text=Compartilhar')

    console.log('‚úÖ Post publicado no Instagram')

    await delay(10000, 15000)
    await browser.close()
  } catch (err) {
      console.error("Erro na postagem Instagram:", err)
      process.exit(1)
  }
})()
